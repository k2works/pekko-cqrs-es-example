# Apache Pekkoを使用したCQRS/EventSourcingサービス開発

## 記事アウトライン

---

## 【第1部】環境構築編

### 1. イントロダクション
- **目的と対象読者**
  - CQRS/Event Sourcingを実践的に学びたいScala開発者
  - Apache Pekko（旧Akka）への移行を検討している開発者
- **この記事で学べること**
  - Apache Pekkoによるイベントソーシング実装
  - CQRS（コマンドクエリ責任分離）の実践的なアーキテクチャ
  - LocalStackを使用したローカル開発環境構築
- **全体の構成**
  - 第1部：環境構築編（本記事）
  - 第2部：サービス構築編

### 2. アーキテクチャ概要
- **CQRS/Event Sourcingとは**
  - CQRS（コマンドクエリ責任分離）の基本概念
  - Event Sourcingパターンの利点と課題
  - なぜPekkoを選択したか（Akkaからの移行背景）
- **システム構成図**
  - コマンド側：Pekko Actors + DynamoDB
  - クエリ側：PostgreSQL + Slick
  - イベント処理：Lambda + DynamoDB Streams
- **データフローの理解**
  - Mutation → Event生成 → 永続化 → Stream → Lambda → Read Model更新 → Query

### 3. 技術スタックの選定
- **コア技術**
  - Scala 3.6.2の採用理由（型安全性、関数型プログラミング）
  - Apache Pekko 1.1.2（型付きアクター、永続化、クラスター）
- **データストア**
  - DynamoDB：イベントストアとしての利点（スケーラビリティ、可用性）
  - PostgreSQL：Read Modelとしての最適化
- **開発環境**
  - LocalStack：AWS サービスのローカルエミュレーション
  - Docker Compose：インフラストラクチャの一元管理
- **API & シリアライゼーション**
  - GraphQL (Sangria)：型安全なAPI設計
  - Protocol Buffers：効率的なイベントシリアライゼーション

### 4. 開発環境のセットアップ
#### 4.1 前提条件の確認
- Java（OpenJDK 17以降）のインストール
- SBT（1.8以降）のセットアップ
- Docker & Docker Composeのインストール
- awslocal CLIのセットアップ（オプション）

#### 4.2 プロジェクトのクローンとビルド
- リポジトリのクローン
- SBTビルドの実行
- Dockerイメージのビルド（`sbt dockerBuildAll`）

#### 4.3 LocalStackの理解とセットアップ
- LocalStackとは何か
- 設定ファイルの解説（docker-compose-common.yml）
- DynamoDBテーブルの作成（tools/dynamodb-setup/）
- DynamoDB Streamsの設定

#### 4.4 PostgreSQLのセットアップ
- Flywayによるマイグレーション戦略
- スキーマ設計（user_accountsテーブル）
- Slick DAOの自動生成

#### 4.5 Lambda関数のデプロイ
- Read Model Updaterの役割
- LocalStackへのデプロイ手順
- イベントソースマッピングの設定

### 5. 設定管理の体系化
#### 5.1 設定ファイルの階層化
- application.conf（エントリーポイント）
- pcqrses.conf（アプリケーション固有設定）
- pekko.conf（Pekkoフレームワーク設定）
- j5ik2o.conf（DynamoDB永続化プラグイン設定）

#### 5.2 環境変数による設定の上書き
- ローカル開発環境
- テスト環境
- 本番環境への対応

#### 5.3 シリアライゼーション設定
- Protocol Buffersの設定
- カスタムシリアライザの登録
- CBORシリアライゼーション

### 6. 初回起動とヘルスチェック
#### 6.1 シングルノードモードでの起動
- `./scripts/run-single.sh up` の実行
- 起動プロセスの確認
- ログの確認方法

#### 6.2 各サービスの動作確認
- Command API：http://localhost:50501/api/graphql
- Query API：http://localhost:50502/api/graphql
- LocalStack：http://localhost:4566
- PostgreSQL：localhost:5432

#### 6.3 GraphQL Playgroundの使い方
- Playgroundへのアクセス
- スキーマの確認
- 基本的なクエリの実行

### 7. E2Eテストによる動作確認
- E2Eテストスクリプトの実行（`./scripts/test-e2e.sh`）
- テストフローの理解
  1. ヘルスチェック
  2. ユーザー作成（Mutation）
  3. イベント処理待機
  4. データ取得（Query）
  5. 整合性検証
- テストのカスタマイズ（環境変数）

### 8. トラブルシューティング
#### 8.1 よくある問題と解決方法
- LocalStackが起動しない
- Lambda関数がイベントを処理しない
- PostgreSQLに接続できない
- DynamoDBにデータが保存されない
- ポートが既に使用されている

#### 8.2 デバッグ手法
- ログの確認方法
- DynamoDBの内容確認（`awslocal dynamodb scan`）
- PostgreSQLの直接クエリ
- Lambda関数のCloudWatch Logs確認

### 9. 開発ワークフローの確立
- コードフォーマット（`sbt fmt`）
- リントチェック（`sbt lint`）
- テスト実行（`sbt test`）
- カバレッジレポート（`sbt testCoverage`）
- 環境の停止とクリーンアップ

### 10. まとめと次のステップ
- 環境構築で学んだこと
- 第2部（サービス構築編）への導入
  - ドメインモデルの設計
  - イベントソーシングの実装
  - GraphQL APIの構築
  - Read Modelの更新

---

## 【第2部】サービス構築編

### 1. ドメイン駆動設計の基礎
#### 1.1 プロジェクト構造の理解
- モジュール構成の説明
- レイヤードアーキテクチャ
  - Domain層（ドメインロジック）
  - Use Case層（アプリケーションサービス）
  - Interface Adapter層（技術的詳細）

#### 1.2 UserAccountドメインモデルの設計
- 集約ルート（UserAccount）
- 値オブジェクト（UserAccountId、UserAccountName、EmailAddress）
- ドメインイベント（UserAccountEvent）
- ビジネスルールの実装

### 2. イベントソーシングの実装
#### 2.1 ドメインイベントの設計
- イベント定義（Created_V1、Renamed_V1、Deleted_V1）
- イベントバージョニング戦略
- Envelopeパターンの採用理由

#### 2.2 Protocol Buffersによるシリアライゼーション
- .protoファイルの定義
- ScalaPBによるコード生成
- シリアライザの実装（UserAccountEventSerializer）
- スナップショットのシリアライゼーション

#### 2.3 Pekko Persistenceの活用
- EventSourcedBehaviorの実装
- PersistenceIdの設計
- イベントハンドラーの実装
- スナップショット戦略

### 3. コマンド側の実装（書き込みモデル）
#### 3.1 UserAccountAggregateの実装
- 型付きアクターの基礎
- コマンドハンドラー（Create、Rename、Delete）
- イベントハンドラー
- 状態管理（UserAccountAggregateState）

#### 3.2 レジストリパターンの実装
- GenericAggregateRegistryの設計
- ローカルモード vs クラスターモード
- Cluster Shardingの設定
- パッシベーション戦略

#### 3.3 Command API（GraphQL）の実装
- スキーマ定義（TypeDefinitions）
- Mutationリゾルバーの実装
- バリデーション戦略
- エラーハンドリング

### 4. クエリ側の実装（読み取りモデル）
#### 4.1 Read Modelの設計
- PostgreSQLスキーマ設計
- 非正規化の戦略
- Flywayによるマイグレーション管理

#### 4.2 Slick DAOの自動生成
- sbt-dao-generatorの活用
- DAOの生成プロセス
- カスタマイズポイント

#### 4.3 Query API（GraphQL）の実装
- スキーマ定義
- Queryリゾルバーの実装
- 検索機能の実装
- ページネーション

### 5. イベント処理の実装
#### 5.1 Read Model Updater（Lambda）の実装
- Lambda Handlerの構造
- イベントのデシリアライゼーション
- PersistentReprの処理
- PostgreSQLへの更新処理

#### 5.2 DynamoDB Streamsの統合
- Streamsの設定
- イベントソースマッピング
- リトライ戦略
- エラーハンドリング

#### 5.3 結果整合性の管理
- 非同期処理の課題
- イベント順序の保証
- 冪等性の実装
- トランザクション境界

### 6. 設定管理とデプロイ
#### 6.1 CommandApiConfigの階層化
- 設定の体系化（actor-timeout、server、load-balancer）
- Typesafe Configの活用
- 環境別設定の管理

#### 6.2 シリアライゼーション戦略
- CborSerializableマーカートレイト
- Protocol Buffers vs CBOR
- シリアライザの登録と設定

#### 6.3 Main.scalaの実装
- アプリケーションのエントリーポイント
- ActorSystemの起動
- グレースフルシャットダウン

### 7. テスト戦略
#### 7.1 ドメインモデルのテスト
- 単体テストの実装
- ビジネスルールの検証
- イミュータビリティのテスト

#### 7.2 アグリゲートのテスト
- ActorTestKitの活用
- UserAccountTestHelperの設計
- テストパターンの再利用
- ローカルモード vs クラスターモードのテスト

#### 7.3 GraphQL APIのテスト
- GraphQLServiceSpecの実装
- バリデーションのテスト
- エラーケースのテスト

#### 7.4 E2Eテストの実装
- テストスクリプトの詳細解説
- リトライ戦略
- 環境変数によるカスタマイズ

### 8. パフォーマンスとスケーラビリティ
#### 8.1 Cluster Shardingによる水平スケーリング
- クラスターモードの起動
- エンティティの分散
- ノードの追加・削除

#### 8.2 最適化ポイント
- イベントスナップショット
- 接続プール（HikariCP）
- Read Modelのインデックス設計
- キャッシング戦略

#### 8.3 モニタリングとロギング
- Logbackの設定
- メトリクスの収集
- トレーシング

### 9. 実践的なトピック
#### 9.1 イベントスキーマの進化
- バージョニング戦略の詳細
- イベントアップキャスト
- 複数バージョンのサポート
- 段階的な移行

#### 9.2 GraphQL APIの改善
- firstName/lastNameへのフィールド分割
- Validation型の活用
- ドメインモデルとの整合性
- APIのユーザビリティ向上

#### 9.3 エラーハンドリングとレジリエンス
- アクターの監督戦略
- リトライと Circuit Breaker
- デッドレター処理
- エラーログの管理

### 10. 本番環境への準備
#### 10.1 セキュリティ考慮事項
- 認証・認可の実装
- APIレート制限
- 入力バリデーション
- 暗号化（転送時・保管時）

#### 10.2 運用上の考慮事項
- デプロイ戦略
- バックアップとリストア
- ディザスタリカバリ
- スケーリング計画

#### 10.3 AWSへのデプロイ
- LocalStackから実際のAWSサービスへの移行
- DynamoDB、Lambda、PostgreSQL (RDS)の設定
- インフラストラクチャのコード化（Terraform）

### 11. まとめと発展的なトピック
- この記事で学んだこと
- CQRS/Event Sourcingのベストプラクティス
- さらなる学習リソース
- コミュニティとサポート

---

## 【第3部】在庫管理サービスのケーススタディ

第3部では、第1部・第2部で学んだ知識を活用し、実践的なビジネスユースケースとして在庫管理サービスを構築します。複数の集約、Sagaパターン、複雑なドメインロジックを含む本格的なシステムを通じて、CQRS/イベントソーシングの実践力を身につけます。

### 1. イントロダクション：在庫管理サービスの要件定義
#### 1.1 ビジネス要件
- 在庫管理の基本機能（商品登録、入庫、出庫、在庫照会）
- 複数倉庫間の在庫移動
- 在庫引当と予約管理
- 自動補充アラート
- 在庫履歴の完全な監査ログ

#### 1.2 システム要件
- 高い整合性要件（在庫のマイナス禁止）
- リアルタイム在庫照会
- ピーク時の高スループット対応
- 複数の販売チャネルからの同時アクセス

#### 1.3 技術的課題
- 在庫引当の競合制御
- 分散トランザクション（注文処理）
- イベントの順序保証
- 結果整合性とビジネス整合性のバランス

### 2. データモデルの設計
#### 2.1 Read Model（PostgreSQL）のスキーマ設計
- 企業テーブル（companies）（新規）
  - 企業ID、企業名、企業種別
  - 企業種別（自社、取引先企業）
  - 住所、連絡先、代表者名
  - 設立年月日、資本金、従業員数
  - 日本語カラム名での定義
  - 自社（D社）および取引先企業の情報
- 商品テーブル（products）
  - 商品ID、商品名、SKU
  - カテゴリ（食品類、日用品）、説明
  - 保管条件（常温、冷蔵、冷凍）
  - 日本語カラム名での定義
  - 約8,000件のデータ
  - ※価格情報は参考情報として保持（今回のスコープでは使用しない）
- 取引先テーブル（customers）
  - 取引先ID、企業ID、取引先名、取引先タイプ
  - 取引先タイプ（スーパー、コンビニ、飲食店、小売店）
  - 住所、連絡先
  - 取引開始日、取引ステータス
  - 日本語カラム名での定義
  - 約430件のデータ
  - ※与信限度額、支払条件などの金額情報は参考情報として保持（今回のスコープでは使用しない）
- 倉庫テーブル（warehouses）
  - 倉庫ID、倉庫名、所在地
  - 延べ床面積、容量
  - 有効フラグ
  - 日本語カラム名での定義
  - 3件のデータ（東京、大阪、福岡）
- 倉庫別区画テーブル（warehouse_zones）
  - 区画ID、倉庫ID、区画名
  - 区画タイプ（常温、冷蔵、冷凍）
  - 区画容量
  - 日本語カラム名での定義
  - 9件のデータ（各倉庫3区画）
- 在庫テーブル（inventories）
  - 在庫ID、商品ID、倉庫ID、区画ID
  - 現在庫数、引当済数、有効在庫数
  - 日本語カラム名での定義
- 受払履歴テーブル（inventory_transactions）
  - 受払ID、商品ID、倉庫ID、区画ID
  - 受払区分（入庫、出庫、移動、調整）
  - 受払数量、受払日時
  - 日本語カラム名での定義
  - 1日約2,000件のデータ

**※参考：注文関連テーブル（今回のスコープ外）**
- 注文テーブル（orders）
  - 注文ID、取引先ID、注文日、配送予定日
  - ステータス（作成済、引当済、確定済、出荷済、キャンセル）
  - ※金額情報は今回のスコープ外
- 注文明細テーブル（order_items）
  - 注文明細ID、注文ID、商品ID
  - 数量
  - ※単価などの金額情報は今回のスコープ外

#### 2.2 DynamoDBのテーブル設計
- イベントストアのテーブル設計
- パーティションキーとソートキーの選択
- グローバルセカンダリインデックス（GSI）の設計
- DynamoDB Streamsの設定

#### 2.3 インデックス戦略
- 検索パフォーマンスの最適化
- 複合インデックスの設計
- カバリングインデックス
- インデックスのメンテナンス

### 3. ドメインに適したデータの作成
#### 3.1 事業概要：卸売事業者D社
- **事業者プロフィール**
  - 社名：株式会社D商事（仮称）
  - 事業形態：食品・日用品の卸売事業
  - 創業：1985年、従業員数：約250名
- **事業規模**
  - 年商：約150億円（※参考情報）
  - 取り扱いSKU数：約8,000品目
  - 1日あたりの平均在庫受払件数：約2,000件
  - ※月間取引量（受注件数）は今回のスコープ外
- **取り扱い商品**
  - 食品類（常温保存：60%、要冷蔵：30%、要冷凍：10%）
    - 加工食品、飲料、調味料、菓子類
    - 生鮮食品（野菜、果物、鮮魚、精肉）
  - 日用品（常温保存：100%）
    - 洗剤、トイレタリー、雑貨
- **主な取引先**
  - スーパーマーケットチェーン：約50社
  - コンビニエンスストア：約30社
  - 飲食店・レストラン：約200店舗
  - その他小売店：約150店舗
- **物流拠点**
  - 東京倉庫（主力拠点）：延べ床面積5,000㎡
  - 大阪倉庫（西日本拠点）：延べ床面積3,500㎡
  - 福岡倉庫（九州拠点）：延べ床面積2,000㎡
  - 各倉庫に常温・冷蔵・冷凍の3区画を保有
- **データ生成の根拠**
  - 上記事業規模に基づくマスタデータ件数の設定
  - 商品構成比率に応じた区画別在庫配分
  - 実業務に即した受払トランザクションデータ生成
  - 1日約2,000件の在庫受払パターン設計
  - ※注文パターンは今回のスコープ外（参考情報として保持）

#### 3.2 マスタデータの準備
- 企業マスタデータ（新規）
  - 自社情報（株式会社D商事）
    - 企業種別：自社
    - 設立年月日：1985年、従業員数：約250名
    - 資本金、代表者名、本社所在地
  - 取引先企業情報
    - 企業種別：取引先企業
    - 主要取引先企業の基本情報
- 商品マスタデータ
  - 商品カテゴリ（食品類、日用品）
  - 商品情報（SKU、価格、説明）
  - 保管条件（常温、冷蔵、冷凍）
  - 約8,000品目のマスタデータ
- 倉庫マスタデータ
  - 倉庫の登録（東京倉庫、大阪倉庫、福岡倉庫）
  - ロケーション情報
  - 倉庫の延べ床面積・容量情報
- 倉庫別区画マスタデータ
  - 区画の登録（常温区画、冷蔵区画、冷凍区画）
  - 区画タイプと倉庫の関連付け
  - 区画ごとの保管条件と容量
  - 各倉庫に3区画（常温・冷蔵・冷凍）
- 取引先マスタデータ
  - 取引先の登録（スーパー、コンビニ、飲食店、小売店）
  - 企業との関連付け
  - 取引先タイプ別の約430社

#### 3.3 テストデータの設計
- 在庫データの作成
  - 初期在庫の設定（約8,000品目）
  - 倉庫・区画ごとの在庫配分
    - 常温保存商品：60%（常温区画）
    - 要冷蔵商品：30%（冷蔵区画）
    - 要冷凍商品：10%（冷凍区画）
  - 区画タイプに応じた商品配置
  - 各倉庫の在庫配分比率（東京：50%、大阪：30%、福岡：20%）
- 受払データのシナリオ
  - 正常系のテストケース
    - 1日2,000件の受払パターン（入庫、出庫、移動、調整）
    - 区画別の受払傾向
  - 異常系のテストケース（在庫不足、在庫引当競合、保管条件違反）
  - ピーク時の負荷テストデータ

**※参考：注文データのシナリオ（今回のスコープ外）**
- 取引先タイプ別の注文パターン
- 月間約50,000件の注文データ

#### 3.4 データ投入スクリプト
- Flywayによるマスタデータ投入
  - 企業マスタ（自社1件 + 取引先企業）
  - 商品マスタ（8,000件）
  - 倉庫マスタ（3件）
  - 倉庫別区画マスタ（9件：各倉庫3区画）
  - 取引先マスタ（430件）
- シードデータのSQL
  - 事業規模に基づくデータ件数
  - 保管条件別の商品分類
  - 企業と取引先の関連データ
  - 初期在庫データ
- テストデータ生成ツール
  - 実業務に即した受払トランザクションデータ生成
  - 受払パターンのシミュレーション（入庫、出庫、移動、調整）
  - ※注文パターンのシミュレーションは今回のスコープ外
- データのクリーンアップ手順

### 4. ドメインモデルの設計
#### 4.1 Bounded Contextの識別
- **企業管理コンテキスト**（Company Management）（新規）
  - 企業情報の管理（自社、取引先企業）
  - 企業基本情報（設立年月日、資本金、従業員数）
  - ※企業マスタは比較的静的なデータのため、CRUD管理とする
  - イベントソーシングの対象外とし、Read Model（PostgreSQL）で直接管理
- **商品カタログコンテキスト**（Product Catalog）
  - 商品情報の管理
  - SKU、カテゴリ（食品類、日用品）、価格
  - 保管条件（常温、冷蔵、冷凍）
- **取引先管理コンテキスト**（Customer Management）
  - 取引先情報の管理
  - 取引先タイプ（スーパー、コンビニ、飲食店、小売店）
  - 取引条件、与信管理
  - 企業との関連管理
- **在庫管理コンテキスト**（Inventory Management）
  - 在庫数量の管理
  - 倉庫間移動
  - 在庫引当
  - 区画別の在庫管理

**※参考：注文管理コンテキスト（今回のスコープ外）**
- **注文管理コンテキスト**（Order Management）
  - 注文の作成と処理（取引先からの受注）
  - 在庫引当との連携
  - 出荷指示
  - ※今回は在庫管理に焦点を当て、注文管理は参考として扱う

#### 4.2 集約の設計
- **Product集約**
  - ProductId、Name、SKU
  - Category（食品類、日用品）、Description
  - StorageCondition（常温、冷蔵、冷凍）
  - 商品の作成、更新、廃止
  - ※Price（価格）は参考情報として保持（今回のスコープでは使用しない）
- **Customer集約**
  - CustomerId、CompanyId、CustomerName、CustomerType
  - CustomerType（スーパー、コンビニ、飲食店、小売店）
  - Address、ContactInfo
  - 取引先の登録、更新、無効化
  - ※CompanyIdで企業テーブルと関連（企業情報はCRUD管理）
  - ※CreditLimit（与信限度額）、PaymentTerms（支払条件）は参考情報として保持（今回のスコープでは使用しない）
- **Warehouse集約**
  - WarehouseId、Name、Location
  - FloorArea（延べ床面積）、Capacity（容量）
  - 倉庫の登録、有効化、無効化
- **WarehouseZone集約**
  - ZoneId、WarehouseId、ZoneName、ZoneType
  - 区画の作成、更新、無効化
  - 区画タイプ（常温、冷蔵、冷凍）
  - ZoneCapacity（区画容量）
- **Inventory集約**
  - InventoryId、ProductId、WarehouseId、ZoneId
  - QuantityOnHand（現在庫）、QuantityReserved（引当済）、QuantityAvailable（有効在庫）
  - 在庫の入庫、出庫、移動、引当、引当解除
  - 区画間の在庫移動
  - 保管条件の整合性チェック

**※参考：Order集約（今回のスコープ外）**
- **Order集約**
  - OrderId、CustomerId、OrderItems
  - Status（Created、Reserved、Confirmed、Shipped、Cancelled）
  - OrderDate（注文日）、DeliveryDate（配送予定日）
  - 注文の作成、確認、キャンセル
  - 取引先タイプに応じた処理
  - ※今回は在庫管理に焦点を当て、注文管理は参考として扱う

#### 4.3 ドメインイベントの設計
- **Product Events**
  - ProductCreated_V1、ProductUpdated_V1、ProductDiscontinued_V1
  - StorageConditionChanged_V1（保管条件変更）
  - ※PriceChanged_V1（価格変更）は参考情報として定義（今回のスコープでは使用しない）
- **Customer Events**
  - CustomerCreated_V1、CustomerUpdated_V1、CustomerDeactivated_V1
  - CustomerTypeChanged_V1（取引先タイプ変更）
  - ※CreditLimitChanged_V1（与信限度額変更）は参考情報として定義（今回のスコープでは使用しない）
- **Warehouse Events**
  - WarehouseCreated_V1、WarehouseUpdated_V1、WarehouseDeactivated_V1
  - CapacityChanged_V1（容量変更）
- **WarehouseZone Events**
  - ZoneCreated_V1、ZoneUpdated_V1、ZoneDeactivated_V1
  - ZoneCapacityChanged_V1（区画容量変更）
- **Inventory Events**
  - InventoryCreated_V1、StockReceived_V1、StockReserved_V1
  - StockReleased_V1、StockTransferred_V1、StockAdjusted_V1
  - ZoneTransferred_V1（区画間移動）
  - StorageConditionViolated_V1（保管条件違反検出）

**※参考：Order Events（今回のスコープ外）**
- **Order Events**
  - OrderCreated_V1、OrderReserved_V1、OrderConfirmed_V1
  - OrderShipped_V1、OrderCancelled_V1
  - DeliveryDateChanged_V1（配送予定日変更）
  - ※今回は在庫管理に焦点を当て、注文イベントは参考として扱う

### 5. 複数集約の実装
#### 5.1 企業マスタのCRUD管理（新規）
- 企業情報の直接管理
  - PostgreSQLへの直接CRUD操作
  - イベントソーシングを使用しない理由
    - 企業情報は比較的静的なデータ
    - 変更頻度が低く、履歴管理の必要性が低い
    - シンプルなCRUD管理で十分
- 企業管理のGraphQL API
  - 企業情報の照会
  - 企業と取引先の関連照会
- 企業マスタのRead Model（自社 + 取引先企業）

#### 5.2 Product集約の実装
- Productドメインモデル
  - Category（食品類、日用品）
  - StorageCondition（常温、冷蔵、冷凍）
  - ※Price（価格）は参考情報として保持
- ProductAggregateアクター
  - 保管条件の管理
- 商品カタログのGraphQL API
- 商品マスタのRead Model（約8,000品目）

#### 5.3 Customer集約の実装
- Customerドメインモデル
  - CompanyIdで企業テーブルと関連
  - CustomerType（スーパー、コンビニ、飲食店、小売店）
  - ※CreditLimit（与信限度額）、PaymentTerms（支払条件）は参考情報として保持
- CustomerAggregateアクター
  - 取引先の登録と管理
  - 企業情報の参照（Read Modelから取得）
  - ※与信チェックは今回のスコープ外
- 取引先管理のGraphQL API
  - 企業情報を含む取引先照会
- 取引先マスタのRead Model（約430社）

#### 5.4 Warehouse集約の実装
- Warehouseドメインモデル
  - FloorArea（延べ床面積）、Capacity（容量）
- WarehouseAggregateアクター
  - 倉庫の容量管理
- 倉庫管理のGraphQL API
- 倉庫マスタのRead Model（3拠点）

#### 5.5 WarehouseZone集約の実装
- WarehouseZoneドメインモデル
  - 区画タイプの管理（常温、冷蔵、冷凍）
  - ZoneCapacity（区画容量）
  - 保管条件の検証
- WarehouseZoneAggregateアクター
  - 区画の作成と管理
  - 容量チェック
- 倉庫別区画のGraphQL API
- 区画マスタのRead Model（9区画）

#### 5.6 Inventory集約の実装
- Inventoryドメインモデル
  - ZoneIdの追加
  - QuantityOnHand、QuantityReserved、QuantityAvailableの計算ロジック
  - 在庫引当の競合制御（楽観的ロック）
  - 区画間移動のロジック
  - 保管条件の整合性チェック（商品の保管条件と区画タイプの一致）
- InventoryAggregateアクター
  - 在庫数量の検証ロジック
  - 在庫引当のビジネスルール
  - 区画ごとの在庫管理
  - 保管条件違反の検出
- 在庫管理のGraphQL API
- 受払履歴のRead Model

**※参考：5.7 Order集約の実装（今回のスコープ外）**
- Orderドメインモデル
  - 注文状態マシン
  - OrderItemsの集計
  - CustomerIdとの関連
  - OrderDate、DeliveryDate
- OrderAggregateアクター
  - 注文作成時のバリデーション
  - 取引先タイプに応じた処理
  - 企業情報の参照（Read Modelから取得）
  - ※与信チェックは金額情報を扱うため今回のスコープ外
- 注文管理のGraphQL API
  - 取引先・企業情報を含む注文照会
- 注文のRead Model
- ※今回は在庫管理に焦点を当て、注文管理の実装は参考として扱う

**※参考：6. Sagaパターンによる注文プロセスの実装（今回のスコープ外）**
#### 6.1 Sagaパターンの基礎
- Long Running Transactionの課題
- Choreography vs Orchestration
- 補償トランザクション（Compensating Transaction）

#### 6.2 OrderSagaの設計
- Sagaの状態遷移
  1. OrderCreated → 在庫引当要求（保管条件を考慮した区画選択）
  2. StockReserved → 注文確認
  3. OrderConfirmed → 出荷指示
  4. （失敗時）StockReservationFailed → 注文キャンセル
  - ※与信チェック（CreditChecked）は金額情報を扱うため今回のスコープ外
- タイムアウト処理
- 補償処理の実装
  - 在庫引当の解除
  - 取引先への通知

#### 6.3 OrderSagaActorの実装
- Pekko Persistenceを使用したSaga状態管理
- イベント駆動によるSagaステップの実行
- エラーハンドリングとリトライ戦略

#### 6.4 Sagaのテスト
- 正常系のテスト
- 異常系のテスト（在庫不足、タイムアウト）
- 補償トランザクションのテスト

**※今回は在庫管理に焦点を当て、Sagaパターンの詳細実装は参考として扱う**
**※実装は簡略化し、在庫引当の競合制御に重点を置く**

### 7. 在庫引当の競合制御
#### 7.1 楽観的ロックの実装
- バージョン番号によるConflict検出
- CASオペレーション（Compare-And-Swap）
- リトライ戦略

#### 7.2 在庫引当アルゴリズム
- FIFO（First In First Out）
- 複数倉庫・区画からの引当戦略
  - 区画タイプを考慮した引当優先順位
  - 商品特性に応じた区画選択
- 在庫の予約と確定
- 区画間での在庫調整

#### 7.3 デッドロック回避
- アクター間の依存関係の最小化
- タイムアウト設定
- 一貫性のあるロック順序

### 8. 複雑なクエリの実装
#### 8.1 在庫照会のRead Model設計
- 商品別在庫サマリー
  - カテゴリ別集計（食品類、日用品）
  - 保管条件別集計（常温、冷蔵、冷凍）
- 倉庫別在庫一覧
  - 3拠点（東京、大阪、福岡）の在庫状況
- 区画別在庫一覧
  - 区画タイプ別集計（9区画）
  - 区画容量と使用率の表示
  - 区画ごとの保管条件表示
- 受払履歴（inventory_transactions）
  - 入庫、出庫、移動、調整の記録
  - 区画情報を含む履歴追跡
  - 1日約2,000件の受払記録
- 低在庫アラート
  - 区画ごとの閾値設定
  - 商品別・倉庫別・区画別のアラート

**※参考：取引先別注文状況（今回のスコープ外）**
- 取引先タイプ別の注文集計
- 月間約50,000件の注文データ
- ※注文データは今回のスコープ外のため、参考として扱う

#### 8.2 マテリアライズドビューの活用
- 集計テーブルの設計
  - 倉庫・区画別集計ビュー
  - 商品・区画別在庫サマリー
  - カテゴリ別・保管条件別在庫集計ビュー
  - ※取引先タイプ別注文集計ビューは今回のスコープ外
- リアルタイム更新 vs バッチ更新
  - 高頻度データ（1日2,000件の受払）の更新戦略
- インデックス戦略
  - 区画IDを含む複合インデックス
  - 保管条件を含むインデックス
  - ※取引先タイプを含むインデックスは参考情報

#### 8.3 複雑なGraphQLクエリ
- ネストされたリレーション
  - Product → Inventory → WarehouseZone → Warehouse
  - Customer → Company（企業情報の取得）
  - ※Order関連のリレーションは今回のスコープ外
- フィルタリング
  - 区画タイプによるフィルタリング
  - 商品カテゴリによるフィルタリング
  - 保管条件によるフィルタリング
  - 取引先タイプによるフィルタリング
  - 企業種別によるフィルタリング（自社、取引先企業）
- ソート、ページネーション
  - 大量データ（約8,000品目、約430社）の効率的な取得
- DataLoaderによるN+1問題の解決
  - 企業情報の効率的な取得

### 9. イベントの順序保証
#### 9.1 順序保証が必要な理由
- 在庫数量の計算
- 状態遷移の整合性
- 監査ログの正確性

#### 9.2 DynamoDB Streamsの順序保証
- シャードキーによるパーティショニング
- 同一集約IDでの順序保証
- 異なる集約間の順序

#### 9.3 Read Model更新の順序制御
- Sequence Numberによる制御
- 重複イベントの検出
- 欠落イベントの検知と対処

### 10. パフォーマンス最適化
#### 10.1 在庫照会のキャッシング
- Redisを使用したキャッシュ層
  - 約8,000品目の商品マスタキャッシュ
  - 3拠点の倉庫・区画情報キャッシュ
  - 頻繁にアクセスされる在庫情報のキャッシュ
- キャッシュの無効化戦略
  - イベント駆動によるキャッシュ更新
- Cache-Aside vs Write-Through

#### 10.2 バッチ処理の最適化
- 在庫集計のバッチ実行
  - 区画別・カテゴリ別集計（1日2,000件の受払）
- 低在庫アラートの定期チェック
  - 区画ごとの閾値監視
- Pekko Streamsによるストリーム処理
  - 大量データの効率的な処理
- ※取引先タイプ別の注文集計は今回のスコープ外

#### 10.3 スケーラビリティの検証
- 負荷テスト（Gatling）
  - ピーク時の在庫受払処理（1日2,000件）
  - 同時アクセス数の想定（430社の取引先）
  - 在庫引当の競合シナリオ
- ボトルネックの特定
- スケーリング戦略の調整
  - 3拠点への負荷分散
- ※注文処理の負荷テストは今回のスコープ外

### 11. 運用とモニタリング
#### 11.1 ビジネスメトリクス
- 在庫受払処理レート
  - 1日約2,000件の受払処理状況
- 在庫引当成功率/失敗率
  - 区画別・保管条件別の成功率
- 平均処理時間
  - 在庫操作（入庫、出庫、移動、調整）別の処理時間
- 区画ごとの稼働率
  - 9区画の使用率と容量監視
- 商品カテゴリ別の受払状況
  - 食品類、日用品の受払比率
- ※注文処理レート、Saga完了率、取引先タイプ別の注文動向は今回のスコープ外

#### 11.2 在庫監査ログ
- 受払履歴による全在庫変動の記録
  - 入庫、出庫、移動、調整の追跡（1日約2,000件）
  - 区画情報を含む詳細履歴
  - 保管条件の整合性記録
- 監査レポートの生成
  - 区画別受払集計レポート（9区画）
  - 在庫差異レポート
  - カテゴリ別・保管条件別集計
  - ※取引先タイプ別出荷レポートは今回のスコープ外
- 不整合の検出と修正
  - 区画ごとの在庫整合性チェック
  - 保管条件違反の検出

#### 11.3 アラートと通知
- 低在庫アラート
  - 区画ごとの閾値監視（9区画）
  - 商品カテゴリ別アラート
- 在庫引当失敗の通知
  - 保管条件不一致の通知
  - 在庫不足の通知
- システム異常の検知
  - 区画別の異常検知
  - 3拠点の死活監視
  - 受払処理の遅延検知
- ※Saga失敗の通知、与信チェック失敗の通知、取引先与信超過アラートは今回のスコープ外

### 12. 高度なトピック
#### 12.1 在庫予測
- 過去の販売データ分析
- 機械学習による需要予測
- 自動発注の実装

#### 12.2 マルチテナント対応
- テナント分離戦略
- データの分離とセキュリティ
- テナントごとのカスタマイズ

#### 12.3 グローバル展開
- マルチリージョンデプロイ
- 地理的分散
- レイテンシの最適化

### 13. まとめと実践演習
#### 13.1 学んだこと
- 複数集約の設計と実装（Product、Customer、Warehouse、WarehouseZone、Inventory）
  - 5つの集約による在庫管理ドメインモデル
  - 企業管理を含むビジネスプロセス
  - 静的マスタ（企業）と動的データ（取引先、在庫）の使い分け
- イベントソーシングとCRUD管理のハイブリッドアーキテクチャ
  - 変更頻度が高いデータ（在庫、取引先）はイベントソーシング
  - 静的なマスタデータ（企業）はCRUD管理
  - 両者を組み合わせた効率的なシステム設計
- 在庫管理特有の課題と解決策
  - 区画管理を含む在庫制御（常温・冷蔵・冷凍）
  - 保管条件の整合性管理
  - 受払履歴による完全な監査ログ
  - 在庫引当の競合制御
  - 企業情報と取引先情報の関連管理
- 本格的なCQRS/イベントソーシングシステムの構築
  - 実業務規模のデータ量（企業、商品8,000、取引先430社、1日2,000件の受払処理）
  - 3拠点・9区画の分散環境
- ※注文管理とSagaパターンは参考として学習（今回の実装スコープ外）

#### 13.2 実践演習
- 在庫棚卸機能の追加
  - 区画ごとの実地棚卸（9区画）
  - 差異調整の実装
  - 棚卸レポートの生成
- 区画間自動移動機能
  - 温度管理が必要な商品の自動振り分け
  - 在庫バランス調整
- 在庫分析機能
  - 商品カテゴリ別の受払分析
  - 保管条件別の回転率分析
  - 区画別の稼働率分析
- 在庫予測機能
  - 過去の受払データに基づく在庫予測
  - 自動発注アラート

**※参考：発展的な演習（今回のスコープ外）**
- 返品処理の実装
  - 区画への戻し入れロジック
  - 保管条件の再検証
- 取引先与信管理の強化
  - 動的な与信限度額調整
  - 取引実績に基づく与信評価
- バッチ注文処理の実装
  - 大口注文の一括処理
  - 複数区画からの引当最適化

#### 13.3 次のステップ
- より複雑なビジネスルールの追加
  - 区画容量管理の自動化
  - 温度監視アラートの実装
  - 季節変動を考慮した在庫最適化
  - 商品のロット管理・賞味期限管理
- 他のBounded Contextとの統合
  - 配送管理コンテキスト
  - 仕入管理コンテキスト
  - ※注文管理コンテキスト（金額情報を含む）
  - ※請求管理コンテキスト（金額情報を含む）
- プロダクション環境への展開
  - 3拠点への分散デプロイ
  - 実業務規模でのスケーリング検証

---

## 補足資料

### A. 用語集
- CQRS、Event Sourcing、Aggregate、Domain Event、Read Model、Event Store 等

### B. 参考資料
- Apache Pekko公式ドキュメント
- CQRS Journey（Microsoft）
- Event Sourcing（Martin Fowler）
- DDD（Domain-Driven Design）

### C. トラブルシューティングFAQ
- よくある質問と回答

---

## 執筆方針

### 各トピックの構成
1. **概要**：そのトピックが何で、なぜ重要か
2. **技術的背景**：設計判断の理由、代替案との比較
3. **実装の詳細**：具体的なコード例と解説
4. **ベストプラクティス**：推奨される使い方、避けるべきパターン
5. **演習/実践**：読者が試せる具体的なステップ

### コードサンプル
- 実際のリポジトリのコードを引用
- ファイルパスと行番号を明記（例：`UserAccount.scala:25-35`）
- 重要な部分をハイライト
- コメントで説明を補足

### 図表
- Plantuml記法でアーキテクチャ図を作成
- データフロー図
- シーケンス図
- 設定ファイルの構造図
