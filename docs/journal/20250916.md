# 作業履歴 2025-09-16

## 概要

2025-09-16の作業内容をまとめています。

この日の作業は、Pekko Clusterを使用したシャーディング環境でのテスト実装に焦点を当てました。

## 技術的背景

### Cluster Shardingとテスティング

Cluster Shardingは分散システムにおける重要なパターンですが、テストは複雑になりがちです。以下の課題に対処する必要がありました：

#### クラスター環境のセットアップ

- **Seed Nodes**: テスト用に単一ノードでクラスターを形成
- **Split Brain Resolver**: ネットワーク分断時の動作を制御
- **Sharding設定**: テスト環境に適したシャード数とパッシベーション設定

#### テストの分離

- **スナップショットディレクトリ**: 各テスト実行で一意のディレクトリを使用してテスト間の干渉を防止
- **クラスターのライフサイクル**: テスト前後で適切にクラスターを起動/停止
- **リソースのクリーンアップ**: テスト終了時にスナップショットディレクトリを削除

### パッシベーション戦略

テストでは`enablePassivation = false`を設定：

- **テストの安定性**: パッシベーションによるタイミング問題を回避
- **デバッグの容易性**: アクターが予期せず停止しないため、問題の特定が容易
- **NoIdleTimeout**: テスト中にアクターが自動的に停止しないようにタイムアウトを無効化

### ShardedUserAccountAggregateSpecの設計

このテストスイートは以下をカバー：

1. **基本的なCRUD操作**: クラスター環境での Create/Get/Rename/Delete の動作確認
2. **シャーディングの検証**: 複数IDに対する同時操作が正しく処理されることを確認
3. **状態の独立性**: 異なるID間で状態が干渉しないことを検証

### テストパターンの再利用

`UserAccountTestHelper`トレイトを継承することで：

- **コードの重複を排除**: ローカルモードテストと同じテストロジックを再利用
- **保守性の向上**: テストロジックの変更が必要な場合、一箇所の修正で両方のテストに反映
- **一貫性の保証**: ローカルモードとクラスターモードで同じテストケースを実行

## コミット: 2098dd0

### メッセージ

```
test: ShardedUserAccountAggregateのクラスターモードテストを追加
Pekko Clusterを使用したシャーディング環境でのUserAccountAggregateの
テストスイートを実装。以下の機能をテスト：
- クラスターモードでのレジストリの動作
- Createコマンドのシャーディング動作
- パッシベーション無効化の設定
```

### 変更されたファイル

- A	modules/command/interface-adapter/src/test/scala/io/github/j5ik2o/pcqrses/command/interfaceAdapter/aggregate/users/ShardedUserAccountAggregateSpec.scala

### 変更内容

```diff
commit 2098dd093a86dacb8f5f34cace9c74f8242513a6
Author: Junichi Kato <j5ik2o@gmail.com>
Date:   Tue Sep 16 09:25:19 2025 +0900

    test: ShardedUserAccountAggregateのクラスターモードテストを追加
    
    Pekko Clusterを使用したシャーディング環境でのUserAccountAggregateの
    テストスイートを実装。以下の機能をテスト：
    - クラスターモードでのレジストリの動作
    - Createコマンドのシャーディング動作
    - パッシベーション無効化の設定

diff --git a/modules/command/interface-adapter/src/test/scala/io/github/j5ik2o/pcqrses/command/interfaceAdapter/aggregate/users/ShardedUserAccountAggregateSpec.scala b/modules/command/interface-adapter/src/test/scala/io/github/j5ik2o/pcqrses/command/interfaceAdapter/aggregate/users/ShardedUserAccountAggregateSpec.scala
new file mode 100644
index 0000000..4a81350
--- /dev/null
+++ b/modules/command/interface-adapter/src/test/scala/io/github/j5ik2o/pcqrses/command/interfaceAdapter/aggregate/users/ShardedUserAccountAggregateSpec.scala
@@ -0,0 +1,222 @@
+package io.github.j5ik2o.pcqrses.command.interfaceAdapter.aggregate.users
+
+import com.typesafe.config.{Config, ConfigFactory}
+import io.github.j5ik2o.pcqrses.command.domain.users.UserAccountId
+import io.github.j5ik2o.pcqrses.command.interfaceAdapter.contract.users.UserAccountProtocol.{Command, CreateReply}
+import io.github.j5ik2o.pcqrses.command.interfaceAdapter.registry.{GenericAggregateRegistry, GenericClusterAggregateRegistry}
+import io.github.j5ik2o.pcqrses.command.interfaceAdapter.test.ActorSpec
+import org.apache.pekko.actor.testkit.typed.scaladsl.TestProbe
+import org.apache.pekko.actor.typed.ActorRef
+import org.apache.pekko.cluster.Cluster
+import org.scalatest.BeforeAndAfterAll
+import org.scalatest.concurrent.Eventually
+import org.scalatest.matchers.should.Matchers
+
+import java.nio.file.Files
+import java.util.{Comparator, UUID}
+
+object ShardedUserAccountAggregateSpec {
+  val id: String = UUID.randomUUID().toString
+
+  val config: Config = ConfigFactory
+    .parseString(
+      s"""
+       |pekko {
+       |  actor {
+       |    provider = cluster
+       |  }
+       |  cluster {
+       |    seed-nodes = ["pekko://StaffClusterRegistrySpec@127.0.0.1:25520"]
+       |    downing-provider-class = "org.apache.pekko.cluster.sbr.SplitBrainResolverProvider"
+       |    sharding {
+       |      number-of-shards = 100
+       |      passivation {
+       |        strategy = none
+       |      }
+       |    }
+       |  }
+       |
+       |  remote.artery {
+       |    canonical {
+       |      hostname = "127.0.0.1"
+       |      port = 25520
+       |    }
+       |  }
+       |
+       |  persistence {
+       |    journal {
+       |      plugin = "pekko.persistence.journal.inmem"
+       |      inmem {
+       |        class = "org.apache.pekko.persistence.journal.inmem.InmemJournal"
+       |        plugin-dispatcher = "pekko.actor.default-dispatcher"
+       |      }
+       |    }
+       |    snapshot-store {
+       |      plugin = "pekko.persistence.snapshot-store.local"
+       |      local {
+       |        dir = "target/snapshot/$id"
+       |      }
+       |    }
+       |  }
+       |  test {
+       |    single-expect-default = 5s
+       |  }
+       |}
+       |""".stripMargin
+    )
+    .withFallback(ConfigFactory.load())
+
+}
+
+class ShardedUserAccountAggregateSpec
+  extends ActorSpec(ShardedUserAccountAggregateSpec.config)
+  with UserAccountTestHelper
+  with Matchers
+  with Eventually
+  with BeforeAndAfterAll {
+  private var registry: ActorRef[Command] = scala.compiletime.uninitialized
+  private var cluster: Cluster = scala.compiletime.uninitialized
+
+  override def beforeAll(): Unit = {
+    super.beforeAll()
+
+    // クラスターを起動
+    cluster = Cluster(system)
+    cluster.join(cluster.selfMember.address)
+
+    // クラスターが形成されるまで待機
+    eventually {
+      cluster.state.members.nonEmpty shouldBe true
+      cluster.state.members.head.status shouldBe org.apache.pekko.cluster.MemberStatus.Up
+    }
+
+    // ClusterModeのRegistryを作成（テスト用にタイムアウトとパッシベーションを無効化）
+    implicit val sys = system
+    registry = spawn(
+      UserAccountAggregateRegistry.create(
+        mode = GenericAggregateRegistry.Mode.ClusterMode,
+        idleTimeout = Some(GenericClusterAggregateRegistry.NoIdleTimeout),
+        enablePassivation = false
+      ),
+      "sharded-user-account-aggregate-registry"
+    )
+  }
+
+  override def afterAll(): Unit = {
+    // クラスターをシャットダウン
+    cluster.leave(cluster.selfMember.address)
+
+    // クラスターがシャットダウンするまで待機
+    Thread.sleep(2000)
+
+    super.afterAll()
+    val snapshotDir = new java.io.File(s"target/snapshot/${ShardedUserAccountAggregateSpec.id}")
+    if (snapshotDir.exists()) {
+      Files
+        .walk(snapshotDir.toPath())
+        .sorted(Comparator.reverseOrder())
+        .forEach(Files.delete(_))
+    }
+  }
+
+  /**
+   * 直接spawnしたアクターにコマンドを送信
+   */
+  override def sendCommand[Reply](
+    userAccountId: UserAccountId,
+    createCommand: UserAccountId => Command,
+    probe: TestProbe[Reply]
+  ): Unit = {
+    registry ! createCommand(userAccountId)
+  }
+
+  "UserAccountAggregate" - {
+    "ユーザアカウントが未作成の状態" - {
+      "Createコマンドを受信したとき" - {
+        "新しいユーザアカウントを作成できる" in
+          testCreateUserAccountOnNotCreated()
+      }
+
+      "Getコマンドを受信したとき" - {
+        "NotFoundを返す" in
+          testGetUserAccountOnNotCreated()
+      }
+    }
+
+    "ユーザアカウントが作成済みの状態" - {
+      "Getコマンドを受信したとき" - {
+        "ユーザアカウント情報を返す" in
+          testGetUserAccountOnCreated()
+      }
+
+      "Renameコマンドを受信したとき" - {
+        "ユーザアカウントの名前を変更できる" in
+          testRenameUserAccountOnCreated()
+      }
+
+      "Deleteコマンドを受信したとき" - {
+        "ユーザアカウントを削除できる" in
+          testDeleteUserAccountOnCreated()
+      }
+    }
+
+    "ユーザアカウントが削除済みの状態" - {
+      "Getコマンドを受信したとき" - {
+        "NotFoundを返す" in
+          testGetUserAccountOnDeleted()
+      }
+    }
+  }
+
+  "ClusterSharding固有の動作" - {
+    "複数IDに対する同時Createが独立して成功する" in {
+      val ids = List.fill(5)(UserAccountId.generate())
+      val probes = ids.map(_ => createTestProbe[CreateReply]())
+
+      ids.zip(probes).foreach { case (id, probe) =>
+        sendCommand(id, id0 => UserAccountAggregateSpecHelper.createCommand(id0, probe.ref), probe)
+      }
+
+      probes.foreach(_.expectMessageType[CreateReply])
+    }
+
+    "異なるID間で状態が干渉しない（Renameしても他IDは影響なし）" in {
+      import io.github.j5ik2o.pcqrses.command.domain.users.*
+      import io.github.j5ik2o.pcqrses.command.interfaceAdapter.contract.users.UserAccountProtocol.*
+
+      val id1 = UserAccountId.generate()
+      val id2 = UserAccountId.generate()
+
+      // 2ユーザ作成
+      createUserAccount(id1)
+      createUserAccount(id2)
+
+      // id1 をリネーム
+      val newName = UserAccountName(FirstName("太一"), LastName("山田"))
+      val renameProbe = createTestProbe[RenameReply]()
+      sendCommand(id1, id => Rename(id, newName, renameProbe.ref), renameProbe)
+      renameProbe.expectMessageType[RenameSucceeded]
+
+      // id1 を取得して名前が更新されたことを確認
+      val getProbe1 = createTestProbe[GetReply]()
+      sendCommand(id1, id => Get(id, getProbe1.ref), getProbe1)
+      val get1 = getProbe1.expectMessageType[GetSucceeded]
+      get1.value.name shouldBe newName
+
+      // id2 は元のままであることを確認
+      val getProbe2 = createTestProbe[GetReply]()
+      sendCommand(id2, id => Get(id, getProbe2.ref), getProbe2)
+      val get2 = getProbe2.expectMessageType[GetSucceeded]
+      get2.value.id shouldBe id2
+      get2.value.name should not be newName
+    }
+  }
+}
+
+private object UserAccountAggregateSpecHelper {
+  import io.github.j5ik2o.pcqrses.command.interfaceAdapter.contract.users.UserAccountProtocol.*
+  import io.github.j5ik2o.pcqrses.command.domain.users.*
+
+  def createCommand(id: UserAccountId, replyTo: org.apache.pekko.actor.typed.ActorRef[CreateReply]): Command =
+    Create(id, UserAccountName(FirstName("花子"), LastName("鈴木")), EmailAddress("hanako@example.com"), replyTo)
+}

```

